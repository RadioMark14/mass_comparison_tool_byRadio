import telebot
from telebot import types
import time
import os

# --- 1. CONFIGURATION (REQUIRED) ---

# !!! IMPORTANT !!!
# Replace 'YOUR_BOT_TOKEN_HERE' with the unique token you get from BotFather.
# Search for @BotFather on Telegram, use the /newbot command, name it "SticksbyMark",
# and it will give you the token.
BOT_TOKEN = "YOUR_BOT_TOKEN_HERE" 

# Mock data for your sticker packs
STICKER_PACKS = {
    "Abstract Cats": {
        "description": "A collection of 20 modern, abstract cat stickers perfect for high-art chat rooms.",
        "price": "5.99 USD",
        "stock": 50
    },
    "Retro Gaming": {
        "description": "Nostalgic 8-bit characters and power-ups for the old-school gamer. 30 unique designs.",
        "price": "7.50 USD",
        "stock": 10
    },
    "Foodie Fun": {
        "description": "Express your hunger with these delicious, animated food stickers. 15 stickers.",
        "price": "4.99 USD",
        "stock": 100
    }
}

# --- 2. BOT INITIALIZATION ---

# Create the bot instance
try:
    bot = telebot.TeleBot(BOT_TOKEN)
except Exception as e:
    # Log an error if initialization fails (e.g., bad token format)
    print(f"Error initializing bot: {e}")
    exit()

# Simple storage for custom sticker requests (for demonstration, in a real app, use a database)
custom_requests = {} 

# --- 3. KEYBOARD GENERATORS ---

def create_main_menu_keyboard():
    """Creates the Reply Keyboard with sticker packs and custom request."""
    # Use ReplyKeyboardMarkup for the main persistent menu
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=False)
    
    # Add sticker pack names to the menu (in two columns for mobile readability)
    pack_names = list(STICKER_PACKS.keys())
    for i in range(0, len(pack_names), 2):
        row = pack_names[i:i+2]
        markup.row(*row)
    
    # Add the special 'Ask a custom sticker' button
    markup.row("üé® Ask a Custom Sticker")
    
    return markup

def create_pack_inline_keyboard(pack_name):
    """Creates an Inline Keyboard for a specific sticker pack product page."""
    markup = types.InlineKeyboardMarkup()
    
    # Use callback data to identify the action and pack
    buy_button = types.InlineKeyboardButton(
        text=f"üõí Buy {pack_name} Pack", 
        callback_data=f"buy_{pack_name.replace(' ', '_')}"
    )
    # The 'back' button is crucial for navigation in inline menus
    back_button = types.InlineKeyboardButton(
        text="‚¨ÖÔ∏è Back to Menu", 
        callback_data="back_to_menu"
    )
    
    markup.add(buy_button)
    markup.add(back_button)
    return markup


# --- 4. MESSAGE HANDLERS ---

@bot.message_handler(commands=['start', 'menu'])
def send_welcome(message):
    """Handles the /start and /menu commands, showing the main menu."""
    markup = create_main_menu_keyboard()
    welcome_text = (
        f"üëã Welcome to *SticksbyMark*, {message.from_user.first_name}!\n\n"
        "I sell unique, hand-crafted sticker packs. Choose a pack below or request "
        "a one-of-a-kind custom design!"
    )
    bot.send_message(
        message.chat.id, 
        welcome_text, 
        parse_mode="Markdown", 
        reply_markup=markup
    )

@bot.message_handler(func=lambda message: message.text in STICKER_PACKS)
def handle_sticker_pack_selection(message):
    """Handles when a user clicks on a sticker pack name from the Reply Keyboard."""
    pack_name = message.text
    pack_info = STICKER_PACKS.get(pack_name)
    
    if not pack_info:
        # Should not happen, but good for safety
        bot.send_message(message.chat.id, "Sorry, I couldn't find details for that pack!")
        return

    # Format the product details message
    details_text = (
        f"*{pack_name} Pack Details*\n\n"
        f"üìú Description: {pack_info['description']}\n"
        f"üí∞ Price: {pack_info['price']}\n"
        f"üì¶ Stock Remaining: {pack_info['stock']}"
    )
    
    inline_markup = create_pack_inline_keyboard(pack_name)
    
    bot.send_message(
        message.chat.id, 
        details_text, 
        parse_mode="Markdown", 
        reply_markup=inline_markup
    )

@bot.message_handler(func=lambda message: message.text == "üé® Ask a Custom Sticker")
def handle_custom_sticker_start(message):
    """Initiates the conversation for a custom sticker request."""
    chat_id = message.chat.id
    
    msg = bot.send_message(
        chat_id, 
        "Great! Let's get your custom sticker started. Please describe your idea in detail (what is it, style, colors, usage, etc.)."
    )
    
    # Register the next function to handle the user's description
    bot.register_next_step_handler(msg, process_custom_sticker_description)

def process_custom_sticker_description(message):
    """Collects the custom sticker description and confirms the request."""
    chat_id = message.chat.id
    description = message.text
    
    # Store the request (or send it to the creator's private channel/email)
    custom_requests[chat_id] = description
    
    confirmation_text = (
        f"‚úÖ Request Received!\n\n"
        f"Your idea: _{description}_\n\n"
        "I've saved your request and Mark will review it shortly. He will contact you directly via Telegram to discuss the quote and timeline. Thank you!"
    )
    
    bot.send_message(
        chat_id, 
        confirmation_text, 
        parse_mode="Markdown", 
        reply_markup=create_main_menu_keyboard() # Bring back the main keyboard just in case
    )


# --- 5. CALLBACK QUERY HANDLER (for Inline Buttons) ---

@bot.callback_query_handler(func=lambda call: True)
def callback_inline(call):
    """Handles all inline button clicks (e.g., Buy, Back)."""
    try:
        if call.data == "back_to_menu":
            # Send a simple message and remove the inline keyboard
            bot.edit_message_text(
                chat_id=call.message.chat.id,
                message_id=call.message.message_id,
                text="You are back to the main selection. Choose a pack below or type /menu.",
                reply_markup=None # Remove the inline keyboard
            )
        
        elif call.data.startswith("buy_"):
            pack_key = call.data.replace("buy_", "").replace('_', ' ')
            
            # Acknowledges the click to stop the 'loading' animation on the button
            bot.answer_callback_query(
                callback_query_id=call.id, 
                text=f"Simulating checkout for {pack_key}..."
            )
            
            # Update the message to show a success/next step (e.g., a payment link)
            checkout_text = (
                f"Processing payment for *{pack_key}*.\n\n"
                "In a real shop, this would be a link to a secure payment gateway (like Stripe or PayPal) "
                "or instructions for direct payment."
            )
            
            bot.edit_message_text(
                chat_id=call.message.chat.id,
                message_id=call.message.message_id,
                text=checkout_text,
                parse_mode="Markdown"
            )

    except Exception as e:
        print(f"Error handling callback: {e}")
        bot.answer_callback_query(
            callback_query_id=call.id, 
            text="An error occurred. Please try again."
        )

# --- 6. MAIN POLLING LOOP ---

if __name__ == '__main__':
    print("Bot is starting...")
    # This loop keeps the bot running and listening for new messages (polling mode)
    while True:
        try:
            # Set up the bot's custom commands that appear in the menu
            bot.set_my_commands([
                types.BotCommand("/start", "Launches the main menu"),
                types.BotCommand("/menu", "Shows the main sticker pack menu"),
            ])
            
            bot.polling(none_stop=True)
            
        except Exception as e:
            # Handle potential connection/API errors and attempt to restart
            print(f"Polling error: {e}. Restarting in 5 seconds...")
            time.sleep(5)

